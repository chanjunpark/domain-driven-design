## 🍃 1장 도메인 모델 시작하기
### ✅ 1.4 도메인 모델 패턴
- 여기서 말하는 도메인 모델은 개념 모델로서의 도메인 모델이 아닌 객체 모델로서의 도메인 모델을 의미한다.
- 도메인 모델은 아키텍처 상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴을 말한다. 
- 배송지 변경 가능 여부를 판단하는 기능이 Order에 있든 OrderState에 있든 중요한 점은 주문과 관련된 중요 업무 규칙을 주문 도메인 모델인 Order나 OrderState에서 구현한다는 점이다.
- 핵심 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있다.
### ✅ 1.5 도메인 모델 도출
- 도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다. 이 과정은 요구사항에서 출발한다.
- "주문할 때 배송지 정보를 바늗시 지정해야 한다" → 필수조건일 때는 생성자에 반영 :)
- "출고를 하면 배송지 정보를 변경할 수 없다", "출고 전에 주문을 취소할 수 있다" → 요구사항에 특정 상태를 전후로 한 제약사항이 기술되어 있다면 이를 반영할 수 있어야 한다. 즉, 주문은 최소한 출고상태를 표현할 수 있어야 함.
### ✅ 1.6 엔티티와 밸류
- 엔티티의 가장 큰 특징은 식별자를 가진다는 것이다. 
- 식별자 생성 방법
    1. 특정 규칙에 따라 생성
        - 주문번호, 운송장번호, 카드번호 등
        - 흔히 사용하는 규칙은 현재 시간과 다른 값을 함께 조립하는 것
    2. UUID나 Nano ID와 같은 고유 식별자 생성기 사용
    3. 값을 직접 입력
    4. 일련번호 사용(시퀀스나 DB의 자동증가 컬럼 사용)
- 자동 증가 컬럼을 제외한 다른 방식은 식별자를 먼저 만들고 엔티티 객체를 생성할 때 식별자를 전달한다. 자동 증가 컬ㄹ럼은 DB 테이블에 데이터를 삽입해야 비로소 값을 알 수 있기 때문에 테이블에 데이터를 추가하기 전에는 식별자를 알 수 없다. 이는 엔티티 객체를 생성할 때 식별자를 전달할 수 없음을 의미한다.
- 밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용한다. 예) 받는사람(이름,핸드폰번호), 주소(주소1, 주소2, 우편번호) → @Embedded
- 밸류 타입이 꼭 두개 이상의 데이터를 가져야 하는 것은 아니다. 의미를 명확히 표현하기 위해 밸류타입을 사용하는 경우도 있다 → OrderLine
- 밸류 타입은 코드의 의미를 더 잘 이해할 수 있도록 한다. 
- 밸류타입을 불변으로 구현하는 가장 중요한 이유 : 안전한 코드를 작성할 수 있다.
- 도메인 모델에 getter/setter 무조건 추가하는 것은 좋지 않은 버릇이다. 특시 setter는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
- 도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성자를 통해 필요한 데이터를 모두 전달해야 한다. 이를 통해 생성자를 호출하는 시점에 데이터 유효성 검사도 진행할 수 있다.
- private setter : 클래스 내부에서 데이터를 변경할 목적으로 사용 → 생성자는 private setter를 포함하고, private setter에서 유효성을 검증해 결과로 Exception을 발생시킴
- setter를 구현해야할 특별한 이유가 없다면 밸류 타입은 불변으로 구현한다. 
### ✅ 1.7 도메인 용어와 유비쿼터스 언어
- 주문의 상태를 개발자가 임의로 STEP1, STEP2, STEP3 처럼 정해쓰지 말고, PAYMENT_WAITING, PREPARING, SHIPPED와 같이 도메인에서 사용하는 용어를 최대한 코드에 반영한다. 

---

## 🍃 2장 아키텍처 개요
### ✅ 2.1 네 개의 영역
- **표현 영역** : HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역에 전달하고 응용 영역의 응답을 HTTP 응답으로 변환하여 전송한다. 
    - 예) HTTP 요청 파라미터 → 객체 타입 / 응용 서비스 리턴 결과 → JSON 변환 후 HTTP 응답으로 클라이언트에 전달
- **응용 영역** : 시스템이 사용자에게 제공해야할 기능을 구현한다. 
    - 예) '주문 등록', '주문 취소', '상품 상세 조회'
    - 응용 영역은 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다. 
    - 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행일 위임한다.
- **도메인 영역** : (1) 도메인 모델을 구현하고, (2) 도메인의 핵심 로직을 구현한다.
    - 예1) Order, OrderLine, ShippingInfo
    - 예2) 주문 → '배송지 변경', '결제 완료', '주문 총액 계산' 과 같은 핵심 로직을 도메인 모델에서 구현
- **인프라 영역** : 구현 기술에 대한 것을 다룸. RDBMS 연동을 처리하고, 메시지 큐에 메시지를 전송하거나 수신하는 기능을 구현하고, 몽고DB나 레디스와의 데이터 연동을 처리한다. 메일발송, HTTP Client를 이용한 REST API 호출 등도 인프라 영역에서 처리한다. 논리적인 개념을 표현하기 보단 실제 구현을 다룬다.
    - 표현, 응용, 도메인 영역은 인프라 영역에서 제공하는 기능을 사용해 필요한 기능을 사용한다. 
### ✅ 2.2 계층 구조 아키텍처
- *[표현] → [응용] → [도메인] → [인프라]* 
- 계층 구조는 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다. 
    - 예) 도메인은 인프라에 의존하지만 표현이나 응용에는 의존하지 않는다.
    - 원칙적으로 바로 아래 계층에만 의존해야 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다. (응용 계층 서비스가 DB 사용을 위해 인프라에 바로 의존)
- **중요한 점** : 표현, 응용, 도메인 계층이 인프라(구현) 계층에 종속된다.
- 상위 계층이 인프라(구현) 계층에 종속됨에 따르는 문제
    1. 인프라(구현)가 완벽하게 동작하기 이전에 서비스(개념)만 테스트하기 어렵다 
    2. 구현 방식을 변경하기 어렵다. 책의 예시는 Drools라는 인프라 영역 기술을 이용하는데, 이런 상황에서 Drools가 아닌 다른 구현 기술을 사용하려면 코드의 많은 부분을 고쳐야 한다. 
- 결국 인프라에 의존하면 **(1) 테스트의 어려움** 과 **(2) 기능 확장의 어려움** 두 가지 문제가 발생함을 알 수 있다.
### ✅ 2.3 DIP
- 추상화한 인터페이스를 사용하는 DIP(의존성 역전 원칙)을 활용함으로써 앞에서 살펴봤던 게층구조의 문제(고수준 모듈이 저수준 모듈에 의존함에 따라 고수준 모듈의 테스트가 어려워지고 기능 확장이 어려워 지는)를 해결할 수 있다.
    - DIP를 활용해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다(== 저수준 모듈인 DroolsRuleDiscounter가 고수준 모듈인 RuleDiscounter 인터페이스에 의존한다)
- DIP 적용의 이점
    1. 구현 기술을 변경하더라도 서비스를 수정할 필요가 없다. 서비스에서 사용할 저수준 구현 객체를 생성하는 코드만 변경하면 된다.
        - 스프링과 같이 의존 주입을 지원하는 프레임워크를 사용하면 설정 코드를 수정해서 쉽게 구현체를 변경할 수 있다
    2. 대역 객체를 활용해 구현 기술이 완성되기 전에도 테스트를 진행할 수 있다. 
        - Mockito라는 Mock 프레임워크를 이용해서 대역객체를 생성하고, 이렇게 생성된 대역객체는 테스트를 수행하는 데 필요한 기능만 수행한다. 
- DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다. DIP를 적용한 결과 구조만 보고 단순하게 구현 클래스에서 인터페이스를 추출하지 말자. 이는 잘못된 구조를 만들어낸다.
    - CalculateDiscountService 입장에서 봤을 때 할인 금액을 구하기 위해 룰 엔진을 사용하는지 직접 연산하는지는 중요하지 않다. 단지 규칙에 따라 할인 금액을 게산한다는 것이 중요할 뿐이다. 즉, '할인 금액 계산'을 추상화한 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치한다.
    - **💡 DIP 적용 시의 추상화 인터페이스는 상위 수준 모듈의 관점에서 도출되어야 하지, 하위 수준 모듈의 구현 객체에서 추출되어서는 안 된다. 즉, 추상 인터페이스는 상위 수준 모듈이 필요로하는 기능 관점에서 설계한다.**
- DIP를 적용하면 [인프라] → [응용] → [도메인] 으로 의존하는 구조가 된다.
### ✅ 2.4 도메인 영역의 주요 구성요소
- 도메인 영역의 주요 구성요소
    - Entity
    - Value
    - Aggregate
    - Repository
    - Domain Service
- 도메인 모델의 엔티티와 DB 테이블 엔티티의 차이
    1. 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 제공한다.
        - 예) 주문을 표현하는 엔티티는 주문과 관련된 데이터 뿐만 아니라 배송지 주소 변경을 위한 기능을 함께 제공함
        - 도메인 모델의 엔티티는 단순히 데이터를 담고 있는 데이터 구조라기 보다는 데이터와 함께 기능을 제공하는 객체이다.
    2. 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해 표현할 수 있다.
        - RDBMS와 같은 관계형 데이터베이스는 밸류 타입을 제대로 표현하기 힘들다.
        - 예컨대 주문과 관련된 데이터를 한 테이블에 모아놓은 경우 '주문자'라는 개념이 드러나지 않고 주문자의 개별 데이터(이름, 연락처, 주소 등)만 드러난다. 
        - 주문 테이블과 주문자 테이블을 분리하는 경우 '주문자'가 가지는 밸류 타입의 의미가 드러나지 않는다. 
        - 반면 도메인 모델의 Orderer는 주문자 개념을 잘 반영하고 도메인 모델을 잘 이해할 수 있도록 돕는다.
- 밸류는 불변으로 구현할 것을 권장하며, 밸류 타입 데이터를 변경할 때는 객체 자체를 완전히 교체한다. 
- 애그리거트, 레퍼지토리 등은 뒤에서 더 자세히 다룬다.
- 도메인 서비스의 요청 처리 흐름
    - [ 컨트롤러에서 서비스를 통해 기능을 실행하면 ] → [ 서비스는 레퍼지토리에 접근해 도메인 객체를 리턴 받고 ] → [ 도메인 객체에 도메인 로직을 실행한 후 ] → [ 그 결과를 컨트롤러에 리턴한다 ]
    - 도메인의 상태를 변경하는 서비스는 변경 상태가 물리 저장소에 올바르게 반영되도록 트랜잭션을 관리해야 한다.
    - 스프링의 @Transactional
- 인프라 tip
    - DIP의 장점을 해치지 않는 범위에서 응용 역역과 도메인 영역에서 구현 기술에 대한 의존을 가져가는 게 나쁘지 않을 수 있다. 예) @Transactional

---

## 🍃 3장 애그리거트(Aggregate)
### ✅ 3.1 애그리거트
- **애그리거트** : 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들기 위해 상위 수준에서 모델을 조망하는 방법
    - 애그리거트는 관련된 객체를 하나의 군으로 묶어준다. 수많은 객체를 애그리거트로 묶어서 바라보면 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준이 되어주기도 한다.
    - 하나의 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.
    - 예) 주문 애그리거트를 만들려면 Order, OrderLine, Orderer와 같은 객체를 함께 생성
- 애그리거트 간의 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다. 
    - 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다
### ✅ 3.2 애그리거트 루트
- **애그리거트의 루트 엔티티** : 애그리거트에 속한 모든 객체가 일관된 상태를 유지하기 위해 애그리거트 전체를 관리하는 주체. 애그리거트는 여러 객체로 구성되기 때문에 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
- 일관성을 유지하기 위해 애그리거트 루트는 애그리거트가 제공해야할 도메인 기능을 구현한다.
    - 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안 된다.
    - 애그리거트 루트를 통해서만 도메인 로직을 구현하는 데 필요한 두 가지 습관
        1. 단순히 필드를 변경하는 setter를 public으로 만들지 않는다.
            > public setter는 도메인의 의미나 의도를 표현하지 못하고 도메인 로직을 도메인 객체가 아닌 응용 영역이나 표현 영역으로 분산시킨다.
        2. 밸류 타입은 불변으로 구현한다.
            > 밸류 타입이 불변인 경우 밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것 뿐이다. 즉, 애그리거트 루트가 제공하는 메서드에 새로운 밸류 객체를 전달해서 값을 변경하는 방법밖에 없다.
    - 애그리거트 루트가 도메인 규칙을 올바르게만 구현하면 애그리거트 전체의 일관성을 올바르게 유지할 수 있다.
- 트랜잭션의 범위는 작을수록 좋다
    > 한 트랜잭션이 한개의 테이블을 수정하는 것과 세개의 테이블을 수정하는 것을 비교하면 성능에서 차이가 발생한다. 여러 테이블을 수정하는 경우 그만큼 잠금 대상이 되는 테이블이 늘어난다.
    - 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
    - 만약 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현한다.
### ✅ 3.4 ID를 이용한 애그리거트 참조
- 애그리거트에서 다른 애그리거트를 참조한다 = 다른 애그리거트의 루트를 참조한다
- 필드를 이용한 애그리거트 참조의 문제점
    1. 편한 탐색 오용
        > 한 애그리거트 내부에서 다른 애그리거트에 접근할 수 있으면 다른 애그리거트의 상태를 변경하는 유횩에 빠지기 쉬움
    2. 성능에 대한 고민
        > 지연로딩과 즉시로딩 전략 사이에서 고민
    3. 확장의 어려움
        > 도메인마다 서로 다른 DBMS를 사용하는 경우 더 이상 다른 애그리거트 루트 참조를 위해 JPA와 같은 단일 기술을 사용할 수 없다.
- **ID를 이용한 애그리거트 참조**
    - ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다. => 모델의 복잡도를 낮춰준다.
    - 응용 서비스에서 필요한 애그리거트를 로딩하므로 애그리거트 수준에서 지연 로딩을 하는 것과 동일한 결과를 만든다.
    - ID를 이용한 참조와 조회의 성능 문제
        > - N+1 조회 문제 발생 : 조회 대상이 N개일 때 N개를 읽어오는 한번의 쿼리와 연관딘 데이터를 읽어오는 쿼리를 N번 실행한다. 조회속도가 느려지는 원인이 된다. 이 문제가 발생하지 않으려면 join을 사용해야 한다.
        > - N+1 조회와 같은 문제가 발생하지 않도록 하려면 조회전용 쿼리를 사용하면 된다. 
### ✅ 3.6 애그리거트를 팩토리로 사용하기
- 애그리거트가 갖고 있는 데이터를 이용해 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려하라. 

---

## 🍃 4장 리포지터리와 모델 구현



